### Delegation of Authentication Extension (delegation)

This extension allows one Client to create a token that can be used by a third-party (here called the Delegate) to gain authenticate to the Relying Party. The Delegate is a WebAuthn Client that may be either owned by the same user or may be owned by another trusted party. This allows behavior similar to "password-sharing" for WebAuthn without proceeding through the Registration Flow once for each Relying Party and Client pair. The Client can also place contraints on the Delegate using this extension. The new flexibility also allows for recovery flows that are more efficient.

#### Extension identifier

​	delegation

#### Operation applicability

​	Registration

#### Client extension input

The Boolean value `true` to indicate that this extension is supported by the Relying Party.

```web-idl
partial dictionary AuthenticationExtensionsClientInputs {
  boolean delegation;
};
```

#### Client extension processing

If the client wishes to produce a delegatable credential, perform the following steps:

1. Let `delegation` be a `DelegationExtensionOutputs` with `action = "create"`
2. Let `delegation.use = null`
3. Let `delegation.create` be a non-null  `DelegationCreationOptions`.
   1. Let `delegation.create.user` be the `PublicKeyCredentialUserEntity` from the Relying Party's `PublicKeyCredentialCreationOptions`
   2. Let `delegation.create.challenge` be a random byte array. The `challenge` MUST be generated as a cryptographically secure value in an environment trusted by the Client, similar to challenges generated by the Relying Party as described in Section 13.1 of the WebAuthn specification.
   3. Let `delegation.create.expiration` reflect how long to allow the credential to work. A null value signifies no expiration policy.
   4. Let `delegation.create.allowCredentials` reflect any pubkeys that are allowed. If null, then all credentials are allowed. 
4. Let `encoded` be a JSON serialization of `delegation.create`.
5. Let `hash` be the SHA-256 hash of `encoded`.
6. Perform an `authenticatorGetAssertion` operation with the Authenticator over this `hash`. The call should specify the only allowed credential as the one used during this registration.
   1. If the Authenticator fails, the Client returns an "`AbortError`" `DOMException`.
7. Let `use` be the response from the `authenticatorGetAssertion` on success.
8. Store or transfer `use` in a trusted manner. The encoding and means of communication are not specified by this document.
9. Return `delegation`.

If the client wishes to use a delegatable credential, perform the following steps:

1. Let `delegation` be a `DelegationExtensionOutputs` with `action = "use"`.
2. Let `delegation.create = null`.
3. Obtain the `AuthenticatorAssertionResponse` produced when processing this extension at registration, and store it in `delegation.use`. If this fails, return an error.
4. Return `delegation`.

If the client wishes to do neither, the client should not process this extension. If it is being processed, then return an "`AbortError`" `DOMException`.

#### Client extension output

```web-idl
enum DelegationIdentifier { "create", "use" };

dictionary DelegationCreationOptions {
	PublicKeyCredentialUserEntity user;
	unsigned long long? expiration = null;	
    sequence<PublicKeyCredentialDescriptor>? allowCredentials = [];
    BufferSource challenge;
}

dictionary DelegationExtensionOutputs {
    DelegationIdentifier action;
    DelegationCreationOptions? create;
    AuthenticatorAssertionResponse? use;
}

partial dictionary AuthenticationExtensionsClientOutputs {
  DelegationExtensionOutputs delegation;
};
```



#### Relying Party extension validation

All failed verifications MUST return an error.

If `delegation.action` is "create":

1. Verify `delegation.create` is non-null
2. Verify that the `delegation.create.user` value is equal to the `user` field in the sent `PublicKeyCredentialCreationOptions`
3. If the authentication suceeds, the Relying Party SHOULD store `delegation.create` until `expiration` milliseconds after the UNIX epoch, keyed by user handle, `delegation.create.user.id`. The Relying Party MUST NOT store `delegation.create`  if authentication fails.
4. Return success.

If `delegation.action` is "use":

1. Verify `delegation.use` is non-null
2. Let `create` be the deserialization of `delegation.use.clientDataJson`.
3. Verify that there is an identical (to `create`)  `DelegationCreationOptions` stored associated with the user handle in this exchange's `PublicKeyCredentialCreationOptions`.
4. Verify that `create.expiration` is less than the number of milliseconds since the UNIX epoch
5. If `create.allowCredentials` is not null, then verify that the public key of the Delegate's `authenticatorData` is in the sequence.
6. Verify that the signature in `delegate.use` is valid for its client and authenticator data. 
7. Return success.

#### Authenticator extension input

None.

#### Authenticator extension processing

None.

#### Authenticator extension output

None.

